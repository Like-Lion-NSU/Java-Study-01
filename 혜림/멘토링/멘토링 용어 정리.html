
<!DOCTYPE html>
<html lang="en" xmlns:http="" xmlns:https="">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<h1>상속</h1>
<h2>개념</h2>
<h3>부모님이 자식들에게 재산을 물려주는 것과 비슷함 (차이가 있다면 자식 클래스가 상속 받고 싶은 부모 클래스를 선택해서 물려받는 점에서 차이가 있음)</h3>

<h2>용어</h2>
<h3>상속 받는 클래스: 자식 클래스 또는 서브 클래스</h3>
<h3>상속 해주는 클래스: 부모 클래스, 상위 클래스 EH는 슈퍼 클래스</h3>

<h2>대상</h2>
<h3>상속을 받게 되면 부모 클래스의 필드와 메서드를 물려받게 됨</h3>
<h3>(단, 접근 제어자인 private을 갖는 필드나 메서드는 상속이 불가하며 패키지가 다를 경우 접근 제어자가 default인 경우도 상속이 불가함)</h3>

<h2>특징</h2>
<h3>자바에서는 자식 클래스가 여러 부모 클래스로부터 다중 상속 받는 것이 불가능함</h3>
<h3>부모 클래스는 여러 개의 자식 클래스에게 상속 가능</h3>

<h2>장점</h2>
<h3>중복된 코드를 줄일 수 있음</h3>
<h3>유지 보수가 편리함</h3>
<h3>통일성이 있으며 다형성을 구현할 수 있음</h3>

<h2>선언 방법</h2>
<h3>상속 받을 자식 클래스 뒤에 extends 키워드를 사용하고 부모 클래스를 적어주면 됨</h3>
``` java
class 자식클래스명 extends 부모클래스명[...]
```

<h2>예시</h2>
<h3>1.</h3>
``` java
class A {
String aField = "클래스 A 필드";
public void aMethod() {
System.out.println(aField);
// System.out.println("A : "+ bField); // 컴파일 에러(자식 필드 사용 불가)
}
}

class B extends A {
String bField = "클래스 B 필드";
public void bMethod() {
System.out.println(aField); // 부모 클래스 필드 사용
System.out.println(bField); // 본인 클래스 필드 사용
// System.out.println("B : "+cField); // 컴파일 에러(자식 필드 사용 불가)
}
}

class C extends B {
String cField = "클래스 C 필드";
public void cMethod() {
System.out.println(aField); // 조부모 클래스 필드 사용
System.out.println(bField); // 부모 클래스 필드 사용
System.out.println(cField); // 본인 클래스 필드 사용
}
}

public class SuperSubEx01 {
public static void main(String[] args) {
System.out.println("----------A----------");
A a = new A();
a.aMethod(); // 본인 메서드 사용
// a.bMethod(); // A(부모) 객체로 B(자식) 메서드 접근 불가
System.out.println("----------A----------");
System.out.println("----------B----------");
B b = new B();
b.aMethod(); // 부모 메서드 사용
b.bMethod(); // 본인 메서드 사용
// b.cMethod(); // B(부모) 객체로 C(자식) 메서드 접근 불가
System.out.println("----------B----------");
System.out.println("----------C----------");
C c = new C();
c.aMethod(); // 조부모 메서드 사용
c.bMethod(); // 부모 메서드 사용
c.cMethod(); // 본인 메서드 사용
System.out.println("----------C----------");
}
}
```
출처: <https://blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220960019390>



<h1>추상클래스</h1>
<h2>개념 </h2>
<h3>하나 이상의 추상 메서드를 포함하는 클래스 </h3>
<h3>(추상 메서드: 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메서드 / 선언 방법: abstract 반환타입 메서드이름(); // 선언부만 있고 구현부가 없다는 의미로 선언부 끝에 바로 세미콜론을 추가함) (오버라이딩: 상속 관계에 있는 부모 클래스에서 이미 정의된 메서드를 자식 클래스에서 같은 특징을 갖는 메서드로 다시 정의하는 것) </h3>

<h2>선언 방법 </h2>
``` java
abstract class 클래스이름 {
...
abstract 반환타입 메서드이름();
...
}
```

<h2>부연 설명</h2>
<h3>동작이 정의되어 있지 않은 추상 메서드를 포함하고 있으므로 인스턴스를 생성할 수 없음! 자식 클래스에서 추상 클래스의 모든 추상 메서드를 오버라이딩하고 나서야 자식 클래스의 인스턴스를 생성할 수 있게 됨 </h3>
<h3>(인스턴스: 여러 상태의 클래스가 동시에 필요할 때 클래스 앞에 new를 붙여서 클래스의 복제본을 만들어서 사용함 이때 클래스의 복제본을 인스턴스라고 함) </h3>
<h3>또한 추상 메서드뿐만 아니라 생성자, 필드, 일반 메서드도 포함할 수 있음 </h3>

<h2>사용 목적 </h2>
<h3>추상 메서드가 포함된 클래스를 상속 받는 자식 클래스가 반드시 추상 메서드를 구현하도록 하기 위함임 </h3>

<h2>예시</h2>
``` java
abstract class Animal { abstract void cry(); } // 추상 클래스인 Animal 클래스는 추상 메서드인 cry() 메서드를 가지고 있음
class Cat extends Animal { void cry() { System.out.println("냐옹냐옹!"); } }
class Dog extends Animal { void cry() { System.out.println("멍멍!"); } }

public class Polymorphism02 {
public static void main(String[] args) {
// Animal a = new Animal(); // 추상 클래스는 인스턴스를 생성할 수 없음.
// Animal 클래스를 상속 받는 자식 클래스인 Dog 클래스와 Cat 클래스는 cry() 메서드를 오버라이딩해야만 인스턴스 생성 가능
Cat c = new Cat();
Dog d = new Dog();

c.cry();
d.cry();
}
}
```

출처: <http://www.tcpschool.com/java/java_polymorphism_abstract>



<h1>인터페이스</h1>
<h2>개념</h2>
<h3>다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스임 (인터페이스는 추상 메서드와 상수만을 포함할 수 있음) </h3>

<h2>장점</h2>
<h3>대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화가 가능함 </h3>
<h3>클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로 개발 시간 단축 가능 </h3>
<h3>클래스와 클래스 간의 관계를 인터페이스로 연결하면 클래스마다 독립적인 프로그래밍 가능 </h3>

<h2>선언 방법 </h2>
``` java
접근제어자 interface 인터페이스이름 {
public static final 타입 상수이름 = 값; // 단 클래스와 달리 인터페이스의 모든 필드는 public static final이어야 하며 모든 메서드는 public abstract여야 함
...
public abstract 메서드이름(매개변수목록);
...
}
```

<h2>부연 설명 </h2>
<h3>추상 클래스와 마찬가지로 자신이 직접 인스턴스를 생성할 수는 없음 </h3>
<h3>인터페이스가 포함하고 있는 추상 메서드를 구현해 줄 클래스를 작성해야 함 </h3>

<h3>구현 방법 </h3>
``` java
class 클래스이름 implements 인터페이스이름 {...}
```

<h2>인터페이스 구현 예시 </h2>
<h3>1.</h3>
``` java
interface Animal { public abstract void cry(); }
class Cat implements Animal {
public void cry() {
System.out.println("냐옹냐옹!");
}
}
```
<h3>2.</h3>
``` java
class Dog implements Animal {
public void cry() {
System.out.println("멍멍!");
}
}
```
<h3>3.</h3>
``` java
public class Polymorphism03 {
public static void main(String[] args) {
Cat c = new Cat();
Dog d = new Dog();

c.cry();
d.cry();
}
}
```

<h2>부연 설명2 </h2>
<h3>자바에서는 상속과 구현을 동시에 할 수 있음 </h3>
<h3>선언 방법 </h3>
<h3>class 클래스이름 extend 상위클래스이름 implements 인터페이스이름 {...} </h3>

<h2>다중 속성 예시 </h2>
<h3>1.</h3>
``` java
// Cat 인터페이스와 Dog 인터페이스를 동시에 구현한 MyPet 클래스에서만 cry() 메서드를 정의하므로 메서드 호출의 모호성이 없음
interface Animal { public abstract void cry(); }
interface Cat extends Animal { public abstract void cry(); }
interface Dog extends Animal { public abstract void cry(); }
```
<h3>2.</h3>
``` java
class MyPet implements Cat, Dog {
public void cry() {
System.out.println("멍멍! 냐옹냐옹!");
}
}
```
<h3>3.</h3>
``` java
public class Polymorphism05 {
public static void main(String[] args) {
MyPet p = new MyPet();
p.cry();
}
}
```

출처: <http://www.tcpschool.com/java/java_polymorphism_interface>



<h1>제네릭</h1>
<h2>개념 </h2>
<h3>클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미함 (특정 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반 타입임) </h3>

<h2>장점</h2>
<h3>잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있음</h3>
<h3>클래스 외부에서 타입을 지정해 주기 때문에 따로 타입을 체크하고 변환해 줄 필요가 없어서 관리하기 편함</h3>
<h3>비슷한 기능을 지원하는 경우 코드의 재사용성이 높아짐</h3>

<h2>사용 방법</h2>
<h3>타입 (<> 속에 넣어서 쓰는 것) | 설명</h3>
<h3>                        T | Type</h3>
<h3>                        E | Element</h3>
<h3>                        K | Key</h3>
<h3>                        V | Value</h3>
<h3>                        N | Number</h3>
<h3>// 반드시 한 글자일 필요는 없으며 설명과 일치해야 할 필요도 없음</h3>

<h2>선언 방법</h2>
<h3>클래스 및 인터페이스 선언</h3>
``` java
public class 클래스이름 <T> {...} // T 타입은 해당 블록 {...} 안에서까지 유효함
  public Interface 인터페이스이름 <T> {...}
    // 제너릭 타입을 두 개로 둘 수도 있음

    //위 생성된 클래스 사용
    public class ClassName <T, K> {...}

    public class Main{
    public static void main(String[] args) {
    ClassName<String, Integer> a = new ClassName<String, Integer>();
    // T는 String이 되며 K는 Integer가 됨
    }
    }
    ```

    <h3>위 상황에서 주의할 점</h3>
    <h3>참조 타입 밖에 올 수 없다는 점 (기초 타입인 int, double, char 같은 것들은 올 수 없음, 그래서 int형 double형 등 Integer, Double와 같은 Wrapper Type으로 씀)</h3>
    <h3>예시</h3>
    ``` java
    class ClassName<E> { // ClassName을 생성할 때 <> 안에 타입 파라미터를 지정함
      private E element;	// 제네릭 타입 변수
      void set(E element) {	// 제네릭 파라미터 메소드
      this.element = element;
      }

      E get() {	// 제네릭 타입 반환 메소드
      return element;
      }
      }

      class Main {
      public static void main(String[] args) {
      ClassName<String> a = new ClassName<String>();
        // a 객체의 ClassName의 E 제네릭 타입은 String으로 모두 변환됨
        ClassName<Integer> b = new ClassName<Integer>();
          // b 객체의 ClassName의 E 제네릭 타입은 Integer으로 모두 변환됨

          a.set("10");
          b.set(10);

          System.out.println("a data : " + a.get());
          // 반환된 변수의 타입 출력
          System.out.println("a E Type : " + a.get().getClass().getName());

          System.out.println();
          System.out.println("b data : " + b.get());
          // 반환된 변수의 타입 출력
          System.out.println("b E Type : " + b.get().getClass().getName());
          }
          }
          ```
          <h3>예시 결과</h3>
          ```  java
          a data : 10
          a E Type : java.lang.String

          b data : 10
          b E Type : java.lang.Integer
          ```

          <h3>메서드의 한정한 제네릭</h3>
          <h3>선언 방법</h3>
          ``` java
          public <T> T genericMethod(T o) { // 제네릭 메서드 // 클래스와는 다르게 반환타입 이전에 <> 제너릭 타입을 선언함
            ...
            } [접근제어자] <제네릭타입> [반환타입] [메서드명]([제네릭타입] [파라미터]) {
              // 텍스트
              }
              ```

              <h2>부연 설명</h2>
              <h3>클래스에서 지정한 제네릭 유형과 별도로 메서드에서 독립적으로 제네릭 유형을 선언하여 쓸 수 있음</h3>
              <h3>메서드의 한정한 제네릭 방식이 필요한 이유는 정적 메서드로 선언할 때 필요하기 때문임 그렇기 때문에 제네릭이 사용되는 메서드를 정적메서드로 두고 싶은 경우 제네릭 클래스와 별도로 독립적인 제네릭이 사용되어야 함</h3>

              <h2>특정 범위 내로 좁혀서 제한하는 방법</h2>
              ``` java
              <K extends T>	// T와 T의 자손 타입만 가능 (K는 들어오는 타입으로 지정 됨)
                <K super T>	// T와 T의 부모(조상) 타입만 가능 (K는 들어오는 타입으로 지정 됨)
                  <? extends T>	// T와 T의 자손 타입만 가능
                  <? super T>	// T와 T의 부모(조상) 타입만 가능
                  <?>		// 모든 타입 가능. <? extends Object>랑 같은 의미

                  extends T: 상한 경계
                  ? super T: 하한 경계
                  <?>: 와일드 카드
                  ```
                  <h2>주의해야할 점</h2>
                  <h3>K extends T와 ? extends T는 비슷한 구조지만 차이점이 있음</h3>
                  <h3>유형 경계를 지정하는 것은 같으나 경계가 지정된 후 K는 특정 타입으로 지정되지만 ?는 타입이 지정되지 않음</h3>
                  <h3>그래서 특정 타입의 데이터를 조작하고자 할 경우 K 같이 특정 제네릭 인수로 지정 해주어야 함</h3>
                  <h2>위 내용의 예시</h2>
                  ``` java
                  /*
                  * Number와 이를 상속하는 Integer, Short, Double, Long 등의
                  * 타입이 지정될 수 있으며, 객체 혹은 메서드를 호출 할 경우 K는
                  * 지정된 타입으로 변환이 된다.
                  */
                  <K extends Number>
                    /*
                    * Number와 이를 상속하는 Integer, Short, Double, Long 등의
                    * 타입이 지정될 수 있으며, 객체 혹은 메서드를 호출 할 경우 지정 되는 타입이 없어
                    * 타입 참조를 할 수는 없다.
                    */
                    <? extends T>	// T와 T의 자손 타입만 가능
                    ```
                    <h2>사용 방법</h2>
                    <h3>1. <K extends T>, <? extends T>: T 타입을 포함한 자식(자손) 타입만 가능하다는 의미</h3>
                    ``` java
                    public class 클래스이름 <K extends Number> {...}
                    // 특정 타입 및 그 하위 타입만 제한하고 싶을 경우에 쓰면 됨
                    ```
                    <h3>2. <K super T>, <? super T>: T 타입의 부모(조상) 타입만 가능하다는 의미</h3>
                    ``` java
                    <K super B>	// B와 A타입만 올 수 있음
                      <K super E>	// E, D, A타입만 올 수 있음
                        <K super A>	// A타입만 올 수 있음
                          <? super B>	// B와 A타입만 올 수 있음
                          <? super E>	// E, D, A타입만 올 수 있음
                          <? super A>	// A타입만 올 수 있음

                          public class 클래스이름 <E extends Comparable<? super E>> {...}
                          // 제네릭 타입에 대한 객체 비교
                          // E extends Comparable: E 객체는 반드시 Comparable을 구현해야 한다는 의미
                          // <E extends Comparable<? super E>>: E 자기 자신 및 조상 타입과 비교할 수 있는 E
                          ```
                          <h3>3. <?> 와일드 카드 // <?>: 어떤 타입이든 상관 없다는 의미 // 보통 데이터가 아닌 기능의 사용에만 관심이 있는 경우 사용할 수 있음</h3>
                          ``` java
                          public class ClassName {...}
                          public class ClassName extends Object {...}
                          ```

                          출처: <https://st-lab.tistory.com/153>

                          <h1>람다</h1>
                          <h2>장점</h2>
                          <h3>코드가 간결해짐</h3>
                          <h3>지연 연산 등을 토애서 성능 향상을 도모할 수 있음</h3>

                          <h2>단점</h2>
                          <h3>코드를 분석하기가 어려워질 수도 있다</h3>

                          <h2>선언 방법</h2>
                          ``` java
                          (매개변수 목록) -> {실행문(람다식 몸)}
                          // 화살표를 기준으로 왼쪽에는 람다식을 실행하기 위한 매개변수가 위치, 오른쪽에는 매개변수를 이용한 실행 코드 혹은 실행 코드 블록이 옴
                          ```
                          <h3>*람다식을 저장할 수 있는 변수는 함수형 인터페이스타입이어야 함*</h3>

                          <h2>예시</h2>
                          ``` java
                          f(x, y) = x + yl // x, y의 합을 구하는 수학의 함수
                          (x, y) -> x + y // 람다식으로 바꾸면 함수 이름을 빼고 간소하게 표현함
                          ```
                          <h2>예시</h2>
                          ``` java
                          (a, b) -> { return a > b ? a : b } // return문이 있는 경우 중괄호를 생략할 수 없음
                          (a, b) ->  a > b ? a : b // 중괄호를 쓰고 싶지 않다면 이처럼 하나의 표현식으로 써주면 됨
                          ```
                          <h2>예시</h2>
                          ``` java
                          Thread thread = new Thread(new Runnable() {
                          @Override
                          public void run() {
                          System.out.println("Start Thread");
                          Thread.sleep(1000);
                          System.out.println("End Thread");
                          }
                          });
                          // 위 코드를 아래 코드로 바꿀 수 있음
                          Thread thread = new Thread(() -> {
                          System.out.println("Start Thread");
                          Thread.sleep(1000);
                          System.out.println("End Thread");
                          });
                          ```

                          출처: <https://hbase.tistory.com/78>
                          <https://nlp.jbnu.ac.kr/PL2021/java_lambda_expression.pdf>

                          <h1>스트림</h1>
                          <h2>개념</h2>
                          <h3>스트림은 데이터의 흐름임</h3>
                          <h3>(생성하기, 가공하기, 결과 만들기)로 나눌 수 있음</h3>
                          <h3>생성하기: 스트림 인스턴스 생성</h3>
                          <h3>가공하기: 필터링 및 맵핑 등 원하는 결과를 만들어가는 중간 작업</h3>
                          <h3>결과 만들기: 최종적으로 결과를 만들어내는 작업</h3>
                          <h3>전체 -> 맵핑 -> 필터링1 -> 필터링2 -> 결과 만들기 -> 결과물</h3>

                          <h2>장점</h2>
                          <h3>배열 또는 컬렉션 인스턴스에 함수 여러 개를 조합해서 원하는 결과를 필터링하고 가공된 결과를 얻을 수 있음 (배열과 컬렉션을 함수형으로 처리할 수 있음)</h3>
                          <h3>람다를 이용해서 코드의 양을 줄이고 간결하게 표현할 수 있음</h3>
                          <h3>병렬처리가 간단하게 가능함 (병렬처리: 하나의 작업을 둘 이상의 작업으로 잘게 나눠서 동시에 진행하는 것)</h3>

                          <h2>생성하기</h2>
                          <h3>기본 타입형 스트림 // range와 rangeClosed는 범위 차이임</h3>
                          ``` java
                          IntStream intStream = IntStream.range(1, 5); // [1, 2, 3, 4]
                          LongStream longStream = LongStream.rangeClosed(1, 5); // [1, 2, 3, 4, 5]
                          ```
                          <h3>문자열 스트림 // 밑 예시는 스트림의 각 문자를 IntStream으로 변환하는 예시임</h3>
                          ``` java
                          IntStream charsStream = “Stream".chars(); // [83, 116, 114, 101, 97, 109]
                          ```
                          ``` java
                          // 각 요소들로 스트림을 만든 예시
                          Stream<String> stringStream = Pattern.compile(", ").splitAsStream("Eric, Elena, Java"); // [Eric, Elena, Java]
                            ```
                            <h2>배열 스트림 // 배열은 Arrays.stream 메서드를 사용함</h2>
                            ``` java
                            String[] arr = new String[]{"a", "b", "c"};
                            Stream<String> stream = Arrays.stream(arr);
                              Stream<String> streamOfArrayPart = Arrays.stream(arr, 1, 3); // 1~2 요소 [b, c]
                                ```
                                <h2>컬렉션 스트림 // 컬렉션 타입(Collection, List, Set)의 경우 인터페이스에 추가된 디폴트 메서드 stream을 이용해서 만들 수 있음</h2>
                                ``` java
                                public interface Collection<E> extends Iterable<E> {
                                  default Stream<E> stream() {
                                    return StreamSupport.stream(spliterator(), false);
                                    }
                                    // ...
                                    }

                                    // 그럼 이렇게 생성할 수 있음
                                    List<String> list = Arrays.asList("a", "b", "c");
                                      Stream<String> stream = list.stream();
                                        Stream<String> parallelStream = list.parallelStream(); // 병렬 처리 스트림
                                          ```
                                          <h2>비어 있는 스트림 // 요소가 없을 때 null 대신 사용할 수 있음</h2>
                                          ``` java
                                          public Stream<String> streamOf(List<String> list) {
                                            return list == null || list.isEmpty()
                                            ? Stream.empty()
                                            : list.stream();
                                            }
                                            ```
                                            <h2>빌더 스트림 // 스트림에 직접적으로 원하는 값을 넣을 수 있음 마지막에 build 메서드로 스트림을 리턴하기</h2>
                                            ``` java
                                            Stream<String> builderStream =
                                              Stream.<String>builder()
                                                .add("Eric").add("Elena").add("Java")
                                                .build(); // [Eric, Elena, Java]

                                                generete() // generete 메서드를 이용하면 Supplier<T>에 해당하는 람다로 값을 넣을 수 있음 Supplier<T>는 인자는 없고 리턴값만 있는 함수형 인터페이스임, 람다에서 리턴하는 값이 들어감

                                                  public static<T> Stream<T> generate(Supplier<T> s) {...}

                                                    // 위에서 생성되는 스트림은 크기가 정해져있지 않고 무한하기 때문에 특정 사이즈로 최대크기를 제한해야 함
                                                    Stream<String> generatedStream = Stream.generate(() -> "gen").limit(5); // [el, el, el, el, el] 5개의 gen이 들어간 스트림이 생성됨
                                                      ```
                                                      <h2>스트림 연결하기 // Stream.concat 메서드를 이용해서 두 개의 스트림을 연결해서 새로운 스트림을 만들어낼 수 있음</h2>
                                                      ``` java
                                                      Stream<String> stream1 = Stream.of("Java", "Scala", "Groovy");
                                                        Stream<String> stream2 = Stream.of("Python", "Go", "Swift");
                                                          Stream<String> concat = Stream.concat(stream1, stream2);
                                                            // [Java, Scala, Groovy, Python, Go, Swift]
                                                            ```
                                                            <h2>가공하기 // 전체 요소 중 같은 API를 이용해서 내가 원하는 것만 뽑아낼 수 있음</h2>
                                                            ``` java
                                                            List<String> names = Arrays.asList("Eric", "Elena", "Java");

                                                              Filtering // 스트림 내 요소들을 하나씩 평가해서 걸러내는 작업임
                                                              Stream<T> filter(Predicate<? super T> predicate);
                                                                ```
                                                                <h2>예시</h2>
                                                                ``` java
                                                                Stream<String> stream =
                                                                  names.stream()
                                                                  .filter(name -> name.contains("a"));
                                                                  // [Elena, Java] // 스트림의 각 요소에 대해서 평가식을 실행하게 되고 ‘a'가 들어간 이름만 들어간 스트림이 리턴됨

                                                                  Mapping // map은 스트림 내 요소들을 하나씩 특정 값으로 변환해줌 (이때 값을 반환하기 위한 람다를 인자로 받음)
                                                                  <R> Stream<R> map(Function<? super T, ? extends R> mapper);
                                                                    // 스트림에 들어가 있는 값이 input이 되어서 특정 로직을 거친 후 output이 되어 새로운 스트림에 담기게 됨 이러한 작업을 mapping이라고 함
                                                                    예시
                                                                    Stream<String> stream =
                                                                      names.stream()
                                                                      .map(String::toUpperCase);
                                                                      // [ERIC, ELENA, JAVA] // 스트림 내 String의 toUpperCase 메서드를 실행해서 대문자로 변환한 값들이 담긴 스트림을 리턴함
                                                                      ```
                                                                      출처: <https://futurecreator.github.io/2018/08/26/java-8-streams/>
</body>
</html>